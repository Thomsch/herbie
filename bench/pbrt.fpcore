(FPCore (cosTheta_i cosTheta_O sinTheta_i sinTheta_O v)
 :name "hair, Mp, upper"
 :precision binary32
 :pre (and (<= -1 cosTheta_i 1) (<= -1 cosTheta_O 1)
           (<= -1 sinTheta_i 1) (<= -1 sinTheta_O 1)
           (> v 0.1))
 (let ([a (/ (* cosTheta_i cosTheta_O) v)]
       [b (/ (* sinTheta_i sinTheta_O) v)])
  (/ (* (exp (- b)) a) (* (sinh (/ 1 v)) 2 v))))

(FPCore (cosTheta_i cosTheta_O sinTheta_i sinTheta_O v)
 :name "hair, Mp, lower"
 :precision binary32
 :pre (and (<= -1 cosTheta_i 1) (<= -1 cosTheta_O 1)
           (<= -1 sinTheta_i 1) (<= -1 sinTheta_O 1)
           (<= v 0.1))
 (let ([a (/ (* cosTheta_i cosTheta_O) v)]
       [b (/ (* sinTheta_i sinTheta_O) v)])
  (exp (+ (- a b (/ 1 v)) 0.6931f0 (log (/ 1 (* 2 v)))))))


(FPCore (sinTheta_O h eta)
 :name "hair, gamma for a refracted ray"
 :precision binary32
 :pre (and (<= -1 sinTheta_O 1)
           (<= -1 h 1)
           (<= 0 eta 10))
 (let* ([sqr_sinTheta_O (* sinTheta_O sinTheta_O)]
        [cosThetaO (sqrt (- 1 sqr_sinTheta_O))])
  (asin (/ h (sqrt (- (* eta eta) (/ sqr_sinTheta_O cosThetaO)))))))

;; Light sampling functions

(FPCore (ux uy maxCos)
 :name "UniformSampleCone, x"
 :precision binary32
 :pre (and (<= 0 ux 1)
           (<= 0 uy 1)
           (<= 0 maxCos 1))
 (let* ([cosTheta (+ (- 1 ux) (* ux maxCos))]
        [sinTheta (sqrt (- 1 (* cosTheta cosTheta)))]
        [phi (* uy 2 PI)])
  (* (cos phi) sinTheta)))

(FPCore (ux uy maxCos)
 :name "UniformSampleCone, y"
 :precision binary32
 :pre (and (<= 0 ux 1)
           (<= 0 uy 1)
           (<= 0 maxCos 1))
 (let* ([cosTheta (+ (- 1 ux) (* ux maxCos))]
        [sinTheta (sqrt (- 1 (* cosTheta cosTheta)))]
        [phi (* uy 2 PI)])
  (* (sin phi) sinTheta)))

(FPCore (ux uy maxCos)
 :name "UniformSampleCone, z"
 :precision binary32
 :pre (and (<= 0 ux 1)
           (<= 0 uy 1)
           (<= 0 maxCos 1))
 (let* ([cosTheta (+ (- 1 ux) (* ux maxCos))]
        [sinTheta (sqrt (- 1 (* cosTheta cosTheta)))]
        [phi (* uy 2 PI)])
  cosTheta))

;; Unsure on reasonable bounds for xi, yi, zi
(FPCore (xi yi zi ux uy maxCos)
 :name "UniformSampleCone 2"
 :precision binary32
 :pre (and (<= -1e4 xi 1e4) (<= -1e4 yi 1e4) (<= -1e4 zi 1e4)
           (<= 0 ux 1) (<= 0 uy 1)
           (<= 0 maxCos 1))
 (let* ([cosTheta (+ (* (- 1 ux) maxCos ux))] ; (lerp ux maxCos 1)
        [sinTheta (sqrt (- 1 (* cosTheta cosTheta)))]
        [phi (* uy 2 PI)])
  (+ (* (cos phi) sinTheta xi)
     (* (sin phi) sinTheta yi)
     (* cosTheta zi))))

(FPCore (normAngle u n0_i n1_i)
 :name "Curve intersection, scale width based on ribbon orientation"
 :precision binary32
 :pre (and (<= 0 normAngle (/ PI 2))
           (<= 0 n0_i 1) (<= 0 n1_i 1)
           (<= 0 u 1))
 (let* ([invSinNormAngle (/ 1 (sin normAngle))]
        [sin0 (* (sin (* (- 1 u) normAngle)) invSinNormAngle)]
        [sin1 (* (sin (* u normAngle)) invSinNormAngle)])
  (+ (* sin0 n0_i) (* sin1 n1_i))))

(FPCore (x tau)
 :name "Lanczos kernel"
 :precision binary32
 :pre (and (<= 1e-5 x 1) (<= 1 tau 5))
 (let ([xp (* x PI)])
  (* (/ (sin (* xp tau)) (* xp tau))
     (/ (sin xp) xp))))

(FPCore (cosTheta_i u1 u2)
 :name "Beckmann Sampler, near normal, slope_x"
 :precision binary32
 :pre (and (> cosTheta_i 0.9999) (<= cosTheta_i 1)
           (<= 0 u1 1) (<= 0 u2 1))
 (let ([r (sqrt (- (log (- 1 u1))))]
       [sinPhi (sin (* 2 PI u2))]
       [cosPhi (cos (* 2 PI u2))])
  (* r cosPhi)))

(FPCore (cosTheta_i u1 u2)
 :name "Beckmann Sampler, near normal, slope_y"
 :precision binary32
 :pre (and (> cosTheta_i 0.9999) (<= cosTheta_i 1)
           (<= 0 u1 1) (<= 0 u2 1))
 (let ([r (sqrt (- (log (- 1 u1))))]
       [sinPhi (sin (* 2 PI u2))]
       [cosPhi (cos (* 2 PI u2))])
  (* r sinPhi)))

(FPCore (cosTheta_i u1 u2)
 :name "Trowbridge-Reitz Sampler, near normal, slope_x"
 :precision binary32
 :pre (and (> cosTheta_i 0.9999) (<= cosTheta_i 1)
           (<= 0 u1 1) (<= 0 u2 1))
 (let ([r (sqrt (/ u1 (- 1 u1)))]
       [phi (* 6.28318530718 u2)])
  (* r (cos phi))))

(FPCore (cosTheta_i u1 u2)
 :name "Trowbridge-Reitz Sampler, near normal, slope_y"
 :precision binary32
 :pre (and (> cosTheta_i 0.9999) (<= cosTheta_i 1)
           (<= 0 u1 1) (<= 0 u2 1))
 (let ([r (sqrt (/ u1 (- 1 u1)))]
       [phi (* 6.28318530718 u2)])
  (* r (sin phi))))

(FPCore (u0 u1 alphax alphay)
 :name "Trowbridge-Reitz Sampler, sample surface normal, cosTheta"
 :precision binary32
 :pre (and (<= 0 u0 1) (<= 0 u1 0.5)
           (<= 0.0001 alphax 1)
           (<= 0.0001 alphay 1))
 (let* ([phi (atan (* (/ alphay alphax) (tan (+ (* 2 PI u1) (* 0.5 PI)))))]
        [sinPhi (sin phi)]
        [cosPhi (cos phi)]
        [alphax2 (* alphax alphax)]
        [alphay2 (* alphay alphay)]
        [alpha2 (/ 1 (+ (/ (* cosPhi cosPhi) alphax2) (/ (* sinPhi sinPhi) alphay2)))]
        [tanTheta2 (/ (* alpha2 u0) (- 1 u0))])
  (/ 1 (sqrt (+ 1 tanTheta2)))))