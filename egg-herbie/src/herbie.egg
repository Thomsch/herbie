;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Datatypes

(datatype HerbieType
  (Type String))

(datatype Math
  ; Ground terms
  (Num Rational)
  (Var HerbieType String)

  ; Custom ops
  (PI HerbieType)
  (E HerbieType)
  (INFINITY HerbieType)
  (TRUE HerbieType)
  (FALSE HerbieType)

  ; comparison
  (Less HerbieType Math Math)
  (LessEq HerbieType Math Math)
  (Greater HerbieType Math Math)
  (GreaterEq HerbieType Math Math)
  (Eq HerbieType Math Math)
  (NotEq HerbieType Math Math)
  (Add HerbieType Math Math)
  (Sub HerbieType Math Math)
  (Mul HerbieType Math Math)
  (Div HerbieType Math Math)

  ;; named exactly as herbie but with caps
  (Pow HerbieType Math Math)
  (Neg HerbieType Math)
  (Sqrt HerbieType Math)
  (Cbrt HerbieType Math) ; cube root
  (Fabs HerbieType Math)
  (Ceil HerbieType Math)
  (Floor HerbieType Math)
  (Round HerbieType Math)
  (Log HerbieType Math)
  (Exp HerbieType Math)
  (If HerbieType Math Math Math)
  (Fma HerbieType Math Math Math)
  (Sin HerbieType Math)
  (Cos HerbieType Math)
  (Tan HerbieType Math)
  (Atan HerbieType Math)
  (Atan2 HerbieType Math Math)
  (Asin HerbieType Math)
  (Acos HerbieType Math)
  (Hypot HerbieType Math Math)
  (Expm1 HerbieType Math)
  (Log1p HerbieType Math)
  (Sinh HerbieType Math)
  (Cosh HerbieType Math)
  (Tanh HerbieType Math)
  (Not HerbieType Math)
  (And HerbieType Math Math)
  (Or HerbieType Math Math)
  )

;; shorthands- must be added to the exclude list of extraction
(define r-zero (rational "0" "1"))
(define r-one  (rational "1" "1"))
(define r-two  (rational "2" "1"))
(define r-three (rational "3" "1"))
(define r-four (rational "4" "1"))
(define r-neg-one (rational "-1" "1"))
(define zero (Num r-zero) :cost 10000000)
(define one  (Num r-one) :cost 10000000)
(define two  (Num r-two) :cost 10000000)
(define three (Num r-three) :cost 10000000)
(define neg-one (Num r-neg-one) :cost 10000000)
(define four (Num r-four) :cost 10000000)

;; numbers have a special type, since they can be any time
(define real (Type "real") :cost 10000000)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Analyses
;; --------
;; This example has three analyses:
;; an interval analysis consisting of a hi and lo component
;; and a non-zero analysis.
;; The non-zero analysis is built off the interval analysis (in order to prove
;; that rewrites are sound, even if some parts of an expr can't be const-evaled)

; TODO: unbounded intervals?
(function hi (Math) Rational :merge (min old new))
(function lo (Math) Rational :merge (max old new))
;; universe is a hack so we can quantify over it
(relation universe (Math HerbieType))
(relation non-zero (Math))
(relation non-negative (Math))
(relation positive (Math))
(relation neq (Math Math))

;; First, constant folding!
;; We don't need an explicit constant folding analysis, we can just union
;; with nums when we can

; Cases
(rewrite (Add ty (Num a) (Num b)) (Num (+ a b)))
(rewrite (Sub ty (Num a) (Num b)) (Num (- a b)))
(rewrite (Mul ty (Num a) (Num b)) (Num (* a b)))
(rewrite (Div ty (Num a) (Num b)) (Num (/ a b)))
(rewrite (Pow ty (Num a) (Num b)) (Num (pow a b)))
(rewrite (Neg ty (Num a)) (Num (neg a)))
;; TODO unimplemented
;; (rewrite (Sqrt (Num a)) (Num res) :when ((= res (sqrt a))))
;; (rewrite (Cbrt (Num a)) (Num res) :when ((= res (cbrt a))))
(rewrite (Fabs ty (Num a)) (Num (abs a)))
(rewrite (Ceil ty (Num a)) (Num (ceil a)))
(rewrite (Floor ty (Num a)) (Num (floor a)))
(rewrite (Round ty (Num a)) (Num (round a)))
(rewrite (Log ty (Num a)) (Num res) :when ((= res (log a))))

;; To check if something is zero, we check that zero is not contained in the
;; interval. There are two possible (overlapping!) cases:
;; - There exists a lo interval, in which case it must be larger than 0
;; - There exists a hi interval, in which case it must be smaller than 0
;; This assumes that intervals are well-formed: lo <= hi at all times.
(rule ((= l (lo e))
       (> l r-zero))
      ((non-zero e)))
(rule ((= h (hi e))
       (< h r-zero))
      ((non-zero e)))

(rule ((= l (lo e))
       (>= l r-zero))
      ((non-negative e)))

(rule ((= l (lo e))
       (> l r-zero))
      ((positive e)))

(rule ((= e (Num ve)))
      ((set (lo e) ve)
       (set (hi e) ve)))

;; The interval analyses are similar to the constant-folding analysis,
;; except we have to take the lower/upper bound of the results we get
(rule ((= e (Add ty a b))
       (= la (lo a))
       (= lb (lo b)))
      ((set (lo e) (+ la lb))))
(rule ((= e (Add ty a b))
       (= ha (hi a))
       (= hb (hi b)))
      ((set (hi e) (+ ha hb))))
      
(rule ((= e (Sub ty a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (- la lb) (- la hb))
               (min (- ha lb) (- ha hb))))
       (set (hi e) 
          (max (max (- la lb) (- la hb))
               (max (- ha lb) (- ha hb))))))

(rule ((= e (Mul ty a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (* la lb) (* la hb))
               (min (* ha lb) (* ha hb))))
       (set (hi e) 
          (max (max (* la lb) (* la hb))
               (max (* ha lb) (* ha hb))))))

(rule ((= e (Div ty a b))
       (= la (lo a))
       (= ha (hi a))
       (= lb (lo b))
       (= hb (hi b)))
      ((set (lo e) 
          (min (min (/ la lb) (/ la hb))
               (min (/ ha lb) (/ ha hb))))
       (set (hi e) 
          (max (max (/ la lb) (/ la hb))
               (max (/ ha lb) (/ ha hb))))))

(rule ((= e (Neg ty a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (lo e) (neg ha))
       (set (hi e) (neg la))))

(rule ((= e (Sqrt ty a)))
      ((set (lo e) r-zero)))

;; TODO: better evaluation of sqrt
(rule ((= e (Sqrt ty a))
       (= loa (lo a)))
      (
        (set (lo e) (sqrt loa))
      ))
(rule ((= e (Sqrt ty a))
       (= hia (hi a)))
      (
        (set (hi e) (sqrt hia))
      ))

; Sqrt infer downwards
(rule ((= e (Sqrt ty a)))
      ((set (lo a) r-zero)))


; TODO: Cbrt


(rule ((= e (Fabs ty a))
       (= la (lo a))
       (= ha (hi a)))
      ((set (lo e) (min (abs la) (abs ha)))
       (set (hi e) (max (abs la) (abs ha)))))

(rule ((= e (Ceil ty a))
       (= la (lo a)))
      ((set (lo e) (ceil la))))
(rule ((= e (Ceil ty a))
       (= ha (hi a)))
      ((set (hi e) (ceil ha))))

(rule ((= e (Floor ty a))
       (= la (lo a)))
      ((set (lo e) (floor la))))
(rule ((= e (Floor ty a))
       (= ha (hi a)))
      ((set (hi e) (floor ha))))

(rule ((= e (Round ty a))
       (= la (lo a)))
      ((set (lo e) (round la))))
(rule ((= e (Round ty a))
       (= ha (hi a)))
      ((set (hi e) (round ha))))

; TODO: Log



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Not equals analysis

(rule ((neq a b))
      ((neq b a)))

(rule ((= t1 (Add ty a b))
       (= lob (lo b))
       (> lob r-zero))
      ((neq (Add ty a b) a)))

(rule ((= t1 (Add ty a b))
       (= hib (hi b))
       (< hib r-zero))
      ((neq (Add ty a b) a)))


;; monotonic functions
(rule ((= t1 (Sqrt ty a))
       (= t2 (Sqrt ty b))
       (neq a b))
      ((neq (Sqrt ty a) (Sqrt ty b))))

(rule ((= t1 (Cbrt ty  a))
       (= t2 (Cbrt ty  b))
       (neq a b))
      ((neq (Cbrt ty  a) (Cbrt ty  b))))


;; UNIVERSE

(rule ((= t (Num a)))
      ((universe t real)))
(rule ((= t (Var ty a)))
      ((universe t ty)))
(rule ((= t (PI real)))
      ((universe t real)))
(rule ((= t (E real)))
      ((universe t real)))

(rule ((= t (Add ty a b)))
      ((universe t ty)))
(rule ((= t (Sub ty a b)))
      ((universe t ty)))
(rule ((= t (Mul ty a b)))
      ((universe t ty)))
(rule ((= t (Div ty a b)))
      ((universe t ty)))
(rule ((= t (Pow ty a b)))
      ((universe t ty)))
(rule ((= t (Neg ty a)))
      ((universe t ty)))
(rule ((= t (Sqrt ty a)))
      ((universe t ty)))
(rule ((= t (Cbrt ty  a)))
      ((universe t ty)))
(rule ((= t (Fabs ty a)))
      ((universe t ty)))
(rule ((= t (Ceil ty a)))
      ((universe t ty)))
(rule ((= t (Floor ty a)))
      ((universe t ty)))
(rule ((= t (Round ty a)))
      ((universe t ty)))
(rule ((= t (Log ty a)))
      ((universe t ty)))
(rule ((= t (Exp ty a)))
      ((universe t ty)))
(rule ((= t (If ty a b c)))
      ((universe t ty)))
(rule ((= t (Fma ty a b c)))
      ((universe t ty)))
(rule ((= t (Sin ty a)))
      ((universe t ty)))
(rule ((= t (Cos ty a)))
      ((universe t ty)))
(rule ((= t (Tan ty a)))
      ((universe t ty)))
(rule ((= t (Atan ty a)))
      ((universe t ty)))
(rule ((= t (Atan2 ty a b)))
      ((universe t ty)))
(rule ((= t (Asin ty a)))
      ((universe t ty)))
(rule ((= t (Acos ty a)))
      ((universe t ty)))
(rule ((= t (Hypot ty a b)))
      ((universe t ty)))
(rule ((= t (Expm1 ty a)))
      ((universe t ty)))
(rule ((= t (Log1p ty a)))
      ((universe t ty)))
      

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Rewrites
;; --------
;; These rewrites were compiled from src/syntax/rules.rkt in the herbie repo,
;; using all rewrites in the `simplify` rewrite group.

(add-ruleset analysis)
(clear-rules)


;; INJECTIVITY ooooohh

(rule ((= t1 (Add ty a b))
       (= t2 (Add ty a c))
       (= t1 t2))
       ((union b c)))

(rule ((= t1 (Mul ty a b))
       (= t2 (Mul ty a c))
       (= t1 t2)
       (non-zero a))
       ((union b c)))

(rule ((= t1 (Div ty a b))
       (= t2 (Div ty a c))
       (= t1 t2)
       (non-zero a))
       ((union b c)))

(rule ((= t1 (Div ty a b))
       (= t2 (Div ty c b))
       (= t1 t2))
       ((union a c)))

(rule ((= t1 (Sqrt ty a))
       (= t2 (Sqrt ty b))
       (= t1 t2))
       ((union a b)))

(rule ((= t1 (Cbrt ty  a))
       (= t2 (Cbrt ty  b))
       (= t1 t2))
       ((union a b)))

;; Commutativity
(rewrite (Add ty a b) (Add ty b a))
(rewrite (Mul ty a b) (Mul ty b a))

;; Associativity
(rewrite (Add ty a (Add ty b c)) (Add ty (Add ty a b) c))
(rewrite (Add ty (Add ty a b) c) (Add ty a (Add ty b c)))
(rewrite (Add ty a (Sub ty b c)) (Sub ty (Add ty a b) c))
(rewrite (Add ty (Sub ty a b) c) (Sub ty a (Sub ty b c)))
(rewrite (Sub ty a (Add ty b c)) (Sub ty (Sub ty a b) c))
(rewrite (Sub ty (Add ty a b) c) (Add ty a (Sub ty b c)))
(rewrite (Sub ty (Sub ty a b) c) (Sub ty a (Add ty b c)))
(rewrite (Sub ty a (Sub ty b c)) (Add ty (Sub ty a b) c))
(rewrite (Mul ty a (Mul ty b c)) (Mul ty (Mul ty a b) c))
(rewrite (Mul ty (Mul ty a b) c) (Mul ty a (Mul ty b c)))
(rewrite (Mul ty a (Div ty b c)) (Div ty (Mul ty a b) c))
(rewrite (Mul ty (Div ty a b) c) (Div ty (Mul ty a c) b))
(rewrite (Div ty a (Mul ty b c)) (Div ty (Div ty a b) c))
(rewrite (Div ty (Mul ty b c) a) (Div ty b (Div ty a c)) :when ((non-zero c)))
(rewrite (Div ty a (Div ty b c)) (Mul ty (Div ty a b) c) :when ((non-zero c)))
(rewrite (Div ty (Div ty b c) a) (Div ty b (Mul ty a c)) :when ((non-zero a)))

;; Counting
(rewrite (Add ty x x) (Mul ty two x))

;; Distributivity
(rewrite (Mul ty a (Add ty b c))         (Add ty (Mul ty a b) (Mul ty a c)))
(rewrite (Mul ty a (Add ty b c))         (Add ty (Mul ty b a) (Mul ty c a)))
(rewrite (Add ty (Mul ty a b) (Mul ty a c)) (Mul ty a (Add ty b c)))
(rewrite (Sub ty (Mul ty a b) (Mul ty a c)) (Mul ty a (Sub ty b c)))
(rewrite (Add ty (Mul ty b a) (Mul ty c a)) (Mul ty a (Add ty b c)))
(rewrite (Sub ty (Mul ty b a) (Mul ty c a)) (Mul ty a (Sub ty b c)))
(rewrite (Add ty (Mul ty b a) a)         (Mul ty (Add ty b one) a))
(rewrite (Add ty a (Mul ty c a))         (Mul ty (Add ty c one) a))

(rewrite (Neg ty (Mul ty a b))       (Mul ty (Neg ty a) b))
(rewrite (Neg ty (Mul ty a b))       (Mul ty a (Neg ty b)))
(rewrite (Mul ty (Neg ty a) b)       (Neg ty (Mul ty a b)))
(rewrite (Mul ty a (Neg ty b))       (Neg ty (Mul ty a b)))
(rewrite (Neg ty (Add ty a b))       (Add ty (Neg ty a) (Neg ty b)))
(rewrite (Add ty (Neg ty a) (Neg ty b)) (Neg ty (Add ty a b)))
(rewrite (Div ty (Neg ty a) b)       (Neg ty (Div ty a b)))
(rewrite (Neg ty (Div ty a b))       (Div ty (Neg ty a) b))

(rewrite (Sub ty a (Mul ty (Neg ty b) c)) (Add ty a (Mul ty b c)))
(rewrite (Sub ty a (Mul ty b c))       (Add ty a (Mul ty (Neg ty b) c)))

;; Difference of squares
(rewrite (Mul ty (Mul ty a b) (Mul ty a b))                           (Mul ty (Mul ty a a) (Mul ty b b)))
(rewrite (Mul ty (Mul ty a a) (Mul ty b b))                           (Mul ty (Mul ty a b) (Mul ty a b)))
(rewrite (Sub ty (Mul ty a a) (Mul ty b b))                           (Mul ty (Add ty a b) (Sub ty a b)))
(rewrite (Sub ty (Mul ty a a) one)                (Mul ty (Add ty a one) (Sub ty a one)))
(rewrite (Add ty (Mul ty a a) (Neg ty one))          (Mul ty (Add ty a one) (Sub ty a one)))

(rule ((= e (Pow ty a b))
       (= loa (lo a))
       (> loa r-zero))
      ((set (Pow ty a b) (Mul ty (Pow ty a (Div ty b two)) (Pow ty a (Div ty b two))))))
(rewrite (Mul ty (Pow ty a b) (Pow ty a b))                           (Pow ty a (Mul ty two b)))
(rewrite (Pow ty a three)
         (Mul ty a (Mul ty a a)))
(rewrite (Pow ty a four)
         (Mul ty (Pow ty a two) (Pow ty a two)))



;; Identity
;; This isn't subsumed by const folding since this can return results
;; even if we can't evaluate a precise value for x
(rewrite (Div ty one (Div ty one x))
         x)
(rewrite (Mul ty x (Div ty one x))
         one)
(rewrite (Mul ty (Div ty one x) x)
         one)

(rewrite (Sub ty x x) zero)
(rewrite (Div ty x x) one)
(rewrite (Div ty zero x) zero)
(rewrite (Mul ty zero x) zero)
(rewrite (Mul ty x zero) zero)

(rewrite (Add ty zero x) x)
(rewrite (Add ty x zero) x)
(rewrite (Sub ty zero x) (Neg ty x))
(rewrite (Sub ty x zero) x)
(rewrite (Neg ty (Neg ty x)) x)
(rewrite (Mul ty one x) x)
(rewrite (Mul ty x one) x)
(rewrite (Div ty x one) x)
(rewrite (Mul ty neg-one x) (Neg ty x))
 
(rewrite (Sub ty a b) (Add ty a (Neg ty b)))
(rewrite (Sub ty a b) (Neg ty (Sub ty b a)))
(rewrite (Add ty a (Neg ty b)) (Sub ty a b))
(rewrite (Neg ty x) (Sub ty zero x))
(rewrite (Neg ty x) (Mul ty neg-one x))

(rewrite (Div ty x y) (Mul ty x (Div ty one y)))
(rewrite (Mul ty x (Div ty one y)) (Div ty x y))
(rewrite (Div ty x y) (Div ty one (Div ty y x))
  :when ((non-zero x)
         (non-zero y)))

(rule ((universe t ty))
      ((union t (Mul ty one t))))

;; Fractions
(rewrite (Div ty (Sub ty a b) c)         (Sub ty (Div ty a c) (Div ty b c)))
(rewrite (Div ty (Mul ty a b) (Mul ty c d)) (Mul ty (Div ty a c) (Div ty b d)))

;; Square root
(rewrite (Mul ty (Sqrt ty x) (Sqrt ty x)) x)
(rewrite (Sqrt ty (Mul ty x x)) (Fabs ty x))

(rewrite (Mul ty (Neg ty x) (Neg ty x)) (Mul ty x x))
(rewrite (Mul ty (Fabs ty x) (Fabs ty x)) (Mul ty x x))

;; Absolute values
(rewrite (Fabs ty (Fabs ty x)) (Fabs ty x))
(rewrite (Fabs ty (Sub ty a b)) (Fabs ty (Sub ty b a)))
(rewrite (Fabs ty (Neg ty x)) (Fabs ty x))
(rewrite (Fabs ty (Mul ty x x)) (Mul ty x x))
(rewrite (Fabs ty (Mul ty a b)) (Mul ty (Fabs ty a) (Fabs ty b)))
(rewrite (Fabs ty (Div ty a b)) (Div ty (Fabs ty a) (Fabs ty b)))

;; Cube root
(rewrite (Pow ty (Cbrt ty  x) three)    x)
(rewrite (Cbrt ty  (Pow ty x three))    x)
(rewrite (Mul ty (Mul ty (Cbrt ty  x) (Cbrt ty  x)) (Cbrt ty  x)) x)
(rewrite (Mul ty (Cbrt ty  x) (Mul ty (Cbrt ty  x) (Cbrt ty  x))) x)
(rewrite (Pow ty (Neg ty x) three)     (Neg ty (Pow ty x three)))

(rewrite (Pow ty (Mul ty x y) three)
         (Mul ty (Pow ty x three) (Pow ty y three)))
(rewrite (Pow ty (Div ty x y) three)
         (Div ty (Pow ty x three) (Pow ty y three)))
 
(rewrite (Pow ty x three) (Mul ty x (Mul ty x x)))
; FIXME: this rewrite is slow and has the potential to blow up the egraph
;        this is bc this rule and the second-to-last difference of squares rule
;        have some cyclic behavior goin on
;        the last identity rule compounds this behavior
(rewrite (Mul ty x (Mul ty x x)) (Pow ty x three))

;; Exponentials
(rule ((= t1 (Exp ty (Log ty x))) ;; verified
       (= lox (lo x))
       (>= lox r-zero))
      ((set (Exp ty (Log ty x))
            x)))
(rewrite (Log ty (Exp ty x)) x)

(rewrite (Exp ty zero) one)
(rewrite (Exp ty one) (E real))
;; (rewrite one               (Exp ty zero))
(rewrite (E real)       (Exp real one))

(rewrite (Exp ty (Add ty a b)) (Mul ty (Exp ty a) (Exp ty b)))
(rewrite (Exp ty (Sub ty a b)) (Div ty (Exp ty a) (Exp ty b)))
(rewrite (Exp ty (Neg ty a))   (Div ty one (Exp ty a)))

(rewrite (Mul ty (Exp ty a) (Exp ty b))      (Exp ty (Add ty a b)))
(rewrite (Div ty one (Exp ty a)) (Exp ty (Neg ty a)))
(rewrite (Div ty (Exp ty a) (Exp ty b))      (Exp ty (Sub ty a b)))
(rewrite (Exp ty (Mul ty a b))                    (Pow ty (Exp ty a) b))
(rewrite (Exp ty (Div ty a two)) (Sqrt ty (Exp ty a)))
(rewrite (Exp ty (Div ty a three)) (Cbrt ty  (Exp ty a)))
(rewrite (Exp ty (Mul ty a two)) (Mul ty (Exp ty a) (Exp ty a)))
(rewrite (Exp ty (Mul ty a three)) (Pow ty (Exp ty a) three))

;; Powers
(rewrite (Pow ty a neg-one) (Div ty one a))
(rewrite (Pow ty a one) a)
(rewrite (Div ty one a) (Pow ty a neg-one))

(rule ((universe a ty))
      ((union (Pow ty a one) a)))

; 0^0 is undefined
(rewrite (Pow ty a zero) one :when ((non-zero a)))
(rewrite (Pow ty one a) one)

(rewrite (Exp ty (Mul ty (Log ty a) b)) (Pow ty a b))
(rewrite (Mul ty (Pow ty a b) a) (Pow ty a (Add ty b one)))
(rewrite (Pow ty a (Num (rational "1" "2"))) (Sqrt ty a))
(rewrite (Pow ty a two) (Mul ty a a))
(rewrite (Pow ty a (Num (rational "1" "3"))) (Cbrt ty  a))
(rewrite (Pow ty a three) (Mul ty (Mul ty a a) a))

; 0^0 is undefined
(rewrite (Pow ty zero a) zero :when ((non-zero a)))

;; Logarithms
(rewrite (Log ty (Mul ty a b)) (Add ty (Log ty a) (Log ty b)) :when ((positive a) (positive b)))
(rewrite (Log ty (Div ty a b)) (Sub ty (Log ty a) (Log ty b)) :when ((positive a) (positive b)))
(rewrite (Log ty (Div ty one a)) (Neg ty (Log ty a)))
(rewrite (Log ty (Pow ty a b)) (Mul ty b (Log ty a)) :when ((positive a)))
(rewrite (Log ty (E real)) one)

;; Trigonometry
(rewrite (Add ty (Mul ty (Cos ty a) (Cos ty a)) (Mul ty (Sin ty a) (Sin ty a))) ;;verified
         one)
(rewrite (Sub ty one (Mul ty (Cos ty a) (Cos ty a))) ;; verified
         (Mul ty (Sin ty a) (Sin ty a)))
(rewrite (Sub ty one (Mul ty (Sin ty a) (Sin ty a))) ;; verified
         (Mul ty (Cos ty a) (Cos ty a)))
(rewrite (Add ty (Mul ty (Cos ty a) (Cos ty a)) (Num (rational "-1" "1"))) ;; verified
         (Neg ty (Mul ty (Sin ty a) (Sin ty a))))
(rewrite (Add ty (Mul ty (Sin ty a) (Sin ty a)) (Num (rational "-1" "1"))) ;; verified
         (Neg ty (Mul ty (Cos ty a) (Cos ty a))))
(rewrite (Sub ty (Mul ty (Cos ty a) (Cos ty a)) one)  ;; verified
         (Neg ty (Mul ty (Sin ty a) (Sin ty a))))
(rewrite (Sub ty (Mul ty (Sin ty a) (Sin ty a)) one)  ;; verified
         (Neg ty (Mul ty (Cos ty a) (Cos ty a))))
(rewrite (Sin ty (Div ty (PI real) (Num (rational "6" "1"))))  ;;verified     
         (Num (rational "1" "2")))
(rewrite (Sin ty (Div ty (PI real) (Num (rational "4" "1"))))       ;; verified
         (Div ty (Sqrt ty two) two))
(rewrite (Sin ty (Div ty (PI real) three))   ;;verified
         (Div ty (Sqrt ty three) two))
(rewrite (Sin ty (Div ty (PI real) two)) ;;verified      
         one)
(rewrite (Sin ty (PI real))  ;;verified
         zero)
(rewrite (Sin ty (Add ty x (PI real)))  ;; verified    
         (Neg ty (Sin ty x)))
(rewrite (Sin ty (Add ty x (Div ty (PI real) two))) ;; verified
         (Cos ty x))
(rewrite (Cos ty (Div ty (PI real) (Num (rational "6" "1"))))   ;; verified
         (Div ty (Sqrt ty three) two))
(rewrite (Cos ty (Div ty (PI real) (Num (rational "4" "1"))))       ;; verified
         (Div ty (Sqrt ty two) two))
(rewrite (Cos ty (Div ty (PI real) three))      ;; verified
         (Num (rational "1" "2")))
(rewrite (Cos ty (Div ty (PI real) two))   ;; verified
         zero)
(rewrite (Cos ty (PI real))     ;; verified
         (Num (rational "-1" "1")))
(rewrite (Cos ty (Add ty x (PI real)))  ;; verified
         (Neg ty (Cos ty x)))
(rewrite (Cos ty (Add ty x (Div ty (PI real) two))) ;; verified
         (Neg ty (Sin ty x)))
(rewrite (Tan ty (Div ty (PI real) (Num (rational "6" "1"))))  ;; verified
         (Div ty one (Sqrt ty three)))
(rewrite (Tan ty (Div ty (PI real) (Num (rational "4" "1"))))  ;; verified
         one)
(rewrite (Tan ty (Div ty (PI real) three)) ;; verified
         (Sqrt ty three))
(rewrite (Tan ty (PI real))  ;; verified
         zero)
(rewrite (Tan ty (Add ty x (PI real)))  ;; verified   
         (Tan ty x))
(rewrite (Tan ty (Add ty x (Div ty (PI real) two))) ;; verified
         (Div ty neg-one (Tan ty x)))
(rewrite (Div ty (Sin ty a) (Add ty one (Cos ty a)))  ;; verified
         (Tan ty (Div ty a two)))
(rewrite (Div ty (Neg ty (Sin ty a)) (Add ty one (Cos ty a))) ;; verified
         (Tan ty (Div ty (Neg ty a) two)))
(rewrite (Div ty (Sub ty one (Cos ty a)) (Sin ty a))  ;; verified
         (Tan ty (Div ty a two)))
(rewrite (Div ty (Sub ty one (Cos ty a)) (Neg ty (Sin ty a))) ;; verified
         (Tan ty (Div ty (Neg ty a) two)))
(rewrite (Div ty (Add ty (Sin ty a) (Sin ty b)) (Add ty (Cos ty a) (Cos ty b))) ;; verified
         (Tan ty (Div ty (Add ty a b) two)))
(rewrite (Div ty (Sub ty (Sin ty a) (Sin ty b)) (Add ty (Cos ty a) (Cos ty b))) ;;verified
         (Tan ty (Div ty (Sub ty a b) two)))

(rewrite (Sin ty zero) zero) ;; verified
(rewrite (Cos ty zero) one) ;; verified
(rewrite (Tan ty zero) zero) ;; verified

(rewrite (Sin ty (Neg ty x)) (Neg ty (Sin ty x))) ;; verified
(rewrite (Cos ty (Neg ty x)) (Cos ty x)) ;; verified
(rewrite (Tan ty (Neg ty x)) (Neg ty (Tan ty x))) ;; verified

; Hyperbolics
(rewrite (Sinh ty x) (Div ty (Sub ty (Exp ty x) (Exp ty (Neg ty x))) two))
(rewrite (Cosh ty x) (Div ty (Add ty (Exp ty x) (Exp ty (Neg ty x))) two))
(rewrite (Tanh ty x) (Div ty (Sub ty (Exp ty x) (Exp ty (Neg ty x))) (Add ty (Exp ty x) (Exp ty (Neg ty x)))))
(rewrite (Tanh ty x) (Div ty (Sub ty (Exp ty (Mul ty two x)) one) (Add ty (Exp ty (Mul ty two x)) one)))
(rewrite (Tanh ty x) (Div ty (Sub ty one (Exp ty (Mul ty (Num (rational "-2" "1")) x))) (Add ty one (Exp ty (Mul ty (Num (rational "-2" "1")) x)))))
(rewrite (Sub ty (Mul ty (Cosh ty x) (Cosh ty x)) (Mul ty (Sinh ty x) (Sinh ty x))) one)
(rewrite (Add ty (Cosh ty x) (Sinh ty x)) (Exp ty x))
(rewrite (Sub ty (Cosh ty x) (Sinh ty x)) (Exp ty (Neg ty x)))


;; --------------------------------------------------
;; -----------------------------------------------
;; OTHER RULES FROM HERBIE- polynomials, fractions, ect

;; Difference of squares flip
;; demand for the rule
(rule
       ((= (Add ty a b) t1))
       ((Sub ty a b)))
(rewrite
       (Add ty a b)
       (Div ty (Sub ty (Mul ty a a) (Mul ty b b)) (Sub ty a b))
       :when
       ((non-zero (Sub ty a b))))

;; demand for the rule
(rule
       ((= (Sub ty a b) t1))
       ((Add ty a b)))
(rewrite
       (Sub ty a b)
       (Div ty (Sub ty (Mul ty a a) (Mul ty b b)) (Add ty a b))
       :when 
       ((non-zero (Add ty a b))))


;; difference-of-cubes
;; sum of cubes
(rewrite
       (Add ty (Pow ty a three) (Pow ty b three))
       (Mul ty (Add ty (Mul ty a a) (Sub ty (Mul ty b b) (Mul ty a b)))
            (Add ty a b)))
;; difference of cubes
(rewrite (Sub ty (Pow ty a three) (Pow ty b three))
         (Mul ty (Add ty (Mul ty a a) (Add ty (Mul ty b b) (Mul ty a b)))
              (Sub ty a b)))

;; flip3-+
;; TODO: refactor this into an OR between all these conditions
;; demand
(rule ((= t1 (Add ty a b)))
      ((Add ty (Mul ty a a) (Sub ty (Mul ty b b) (Mul ty a b)))))
(rewrite (Add ty a b)
         (Div ty (Add ty (Pow ty a three) (Pow ty b three))
              (Add ty (Mul ty a a) (Sub ty (Mul ty b b) (Mul ty a b))))
         :when ((non-zero (Add ty (Mul ty a a) (Sub ty (Mul ty b b) (Mul ty a b))))))
(rewrite (Add ty a b)
         (Div ty (Add ty (Pow ty a three) (Pow ty b three))
              (Add ty (Mul ty a a) (Sub ty (Mul ty b b) (Mul ty a b))))
         :when ((non-zero a)))
(rewrite (Add ty a b)
         (Div ty (Add ty (Pow ty a three) (Pow ty b three))
              (Add ty (Mul ty a a) (Sub ty (Mul ty b b) (Mul ty a b))))
         :when ((non-zero b)))
(rewrite (Add ty a b)
         (Div ty (Add ty (Pow ty a three) (Pow ty b three))
              (Add ty (Mul ty a a) (Sub ty (Mul ty b b) (Mul ty a b))))
         :when ((neq a b)))


;;flip3--
;; demand
(rule ((= t1 (Sub ty a b)))
      ((Add ty (Mul ty a a) (Add ty (Mul ty b b) (Mul ty a b)))))
(rewrite (Sub ty a b)
         (Div ty (Sub ty (Pow ty a three) (Pow ty b three))
              (Add ty (Mul ty a a) (Add ty (Mul ty b b) (Mul ty a b))))
         :when ((non-zero a))) ;; when a and b are non-zero a^2+b^2-ab is positive => a^2+b^2+ab is positive
(rewrite (Sub ty a b)
         (Div ty (Sub ty (Pow ty a three) (Pow ty b three))
              (Add ty (Mul ty a a) (Add ty (Mul ty b b) (Mul ty a b))))
         :when ((non-zero b)))
(rewrite (Sub ty a b)
         (Div ty (Sub ty (Pow ty a three) (Pow ty b three))
              (Add ty (Mul ty a a) (Add ty (Mul ty b b) (Mul ty a b))))
         :when ((neq a b)))
(rewrite (Sub ty a b)
         (Div ty (Sub ty (Pow ty a three) (Pow ty b three))
              (Add ty (Mul ty a a) (Add ty (Mul ty b b) (Mul ty a b))))
         :when ((non-zero (Add ty (Mul ty a a) (Add ty (Mul ty b b) (Mul ty a b))))))


;;fractions transform
(rewrite (Sub ty (Div ty a c) (Div ty b c))
         (Div ty (Sub ty a b) c))

(rewrite (Add ty (Div ty a c) (Div ty b c))
         (Div ty (Add ty a b) c))

(rewrite (Add ty (Div ty a b) (Div ty c d))
         (Div ty (Add ty (Mul ty a d) (Mul ty b c))
              (Mul ty b d)))

(rewrite (Sub ty (Div ty a b) (Div ty c d))
         (Div ty (Sub ty (Mul ty a d) (Mul ty b c))
              (Mul ty b d)))

(rewrite (Mul ty (Div ty a b) (Div ty c d))
         (Div ty (Mul ty a c) (Mul ty b d)))

(rewrite (Div ty a b)
         (Div ty (Neg ty a) (Neg ty b)))


;; squares transform
(rule ((= t1 (Sqrt ty (Mul ty x y)))
       (= lox (lo x))
       (= loy (lo y))
       (>= lox r-zero)
       (>= loy r-zero))
      ((set (Sqrt ty (Mul ty x y))
            (Mul ty (Sqrt ty x) (Sqrt ty y)))))

(rule ((= t1 (Sqrt ty (Div ty x y)))
       (non-zero (Sqrt ty y)))
      ((set (Div ty (Sqrt ty x) (Sqrt ty y))
            t1)))

(rewrite (Sqrt ty (Pow ty x y))
         (Pow ty x (Div ty y two)) :when ((non-negative x)))

(rewrite (Pow ty (Sqrt ty x) y)
         (Pow ty x (Div ty y two)))
       
(rewrite (Mul ty (Sqrt ty x) (Sqrt ty y))
         (Sqrt ty (Mul ty x y)))

(rewrite (Div ty (Sqrt ty x) (Sqrt ty y))
         (Sqrt ty (Div ty x y))
         :when ((non-zero y)))

(rule ((universe t ty)
       (= lox (lo t))
       (>= lox r-zero))
      ((union t (Mul ty (Sqrt ty t) (Sqrt ty t)))))


;; cubes transform

(rewrite (Cbrt ty  (Mul ty x y))
         (Mul ty (Cbrt ty  x) (Cbrt ty  y)))
(rewrite (Cbrt ty  (Div ty x y))
         (Div ty (Cbrt ty  x) (Cbrt ty  y)))
(rewrite (Mul ty (Cbrt ty  x) (Cbrt ty  y))
         (Cbrt ty  (Mul ty x y)))
(rewrite (Div ty (Cbrt ty  x) (Cbrt ty  y))
         (Cbrt ty  (Div ty x y)))
(rule ((universe x ty))
      ((union x (Mul ty (Cbrt ty  x) (Mul ty (Cbrt ty  x) (Cbrt ty  x))))))
(rule ((universe x ty))
      ((union x (Cbrt ty  (Pow ty x three)))))


(rewrite (Pow ty (Exp ty a) b) ;; verified
         (Exp ty (Mul ty a b)))
(rewrite (Pow ty a b) ;; verified
         (Exp ty (Mul ty (Log ty a) b))
         :when ((positive a)))
(rewrite (Mul ty (Pow ty a b) (Pow ty a c)) ;; verified
         (Pow ty a (Add ty b c))) ;; two integers cannot sum to a fraction
(rewrite (Mul ty (Pow ty b a) (Pow ty c a)) ;; verified
         (Pow ty (Mul ty b c) a)) ;; either neg -> a is an integer

;; if a is zero, both b and zero must be strictly positive
;; if a is positive, a^b is positive
(rewrite (Pow ty (Pow ty a b) c) ;; verified
         (Pow ty a (Mul ty b c))
         :when ((non-negative a)))
(rewrite (Pow ty a (Neg ty b)) ;; verified
         (Div ty one (Pow ty a b)) :when ((non-zero a)))
(rewrite (Div ty one (Pow ty a b)) ;; verified
         (Pow ty a (Neg ty b)))
(rewrite (Div ty (Pow ty a b) (Pow ty a c)) ;; verified
         (Pow ty a (Sub ty b c)))
(rewrite (Pow ty a (Sub ty b c))
         (Div ty (Pow ty a b) (Pow ty a c)) :when ((positive a)))
;; a could be negative, and also a*b could be negative
(rewrite (Pow ty a (Mul ty b c))
         (Pow ty (Pow ty a b) c)
         :when ((non-negative a) (non-negative (Pow ty a b))))
(rewrite (Pow ty a (Add ty b c))
         (Mul ty (Pow ty a b) (Pow ty a c))
         :when ((non-negative a)))
(rewrite (Pow ty (Mul ty b c) a)
         (Mul ty (Pow ty b a) (Pow ty c a))
         :when ((non-negative b) (non-negative c))) ;; or a is an integer!
(rewrite (Sqrt ty a)
         (Pow ty a (Div ty one two)))
(rewrite (Mul ty a a) (Pow ty a two))
(rewrite (Cbrt ty  a) (Pow ty a (Div ty one three)))
(rewrite (Mul ty (Mul ty a a) a) (Pow ty a three))


;; log factor
(rewrite (Add ty (Log ty a) (Log ty b)) ;; we know a and b pos
       (Log ty (Mul ty a b)))
(rewrite (Sub ty (Log ty a) (Log ty b)) ;; a and b positive
         (Log ty (Div ty a b)))
(rewrite (Neg ty (Log ty a)) (Log ty (Div ty one a))) ;; a positive


;; trig expand
(rewrite (Sin ty (Add ty a b))
         (Add ty (Mul ty (Sin ty a) (Cos ty b))
              (Mul ty (Cos ty a) (Sin ty b)))) ;; verified
(rewrite (Cos ty (Add ty a b))
         (Sub ty (Mul ty (Cos ty a) (Cos ty b))
              (Mul ty (Sin ty a) (Sin ty b)))) ;; verified
(rewrite (Tan ty (Add ty x y)) ;; verified
         (Div ty (Add ty (Tan ty x) (Tan ty y))
              (Sub ty one (Mul ty (Tan ty x) (Tan ty y)))))
(rewrite (Sin ty (Sub ty x y)) ;; verified
         (Sub ty (Mul ty (Sin ty x) (Cos ty y))
               (Mul ty (Cos ty x) (Sin ty y))))
(rewrite (Cos ty (Sub ty x y)) ;; verified
         (Add ty (Mul ty (Cos ty x) (Cos ty y))
              (Mul ty (Sin ty x) (Sin ty y))))
       
(rewrite (Sin ty (Mul ty two x)) ;; verified
         (Mul ty two (Mul ty (Sin ty x) (Cos ty x))))
(rewrite (Sin ty (Mul ty three x)) ;; verified
         (Sub ty (Mul ty three (Sin ty x))
              (Mul ty four (Pow ty (Sin ty x) three))))
(rewrite (Mul ty two (Mul ty (Sin ty x) (Cos ty x))) ;; verified
         (Sin ty (Mul ty two x)))
(rewrite (Sub ty (Mul ty three (Sin ty x)) ;; verified
              (Mul ty four (Pow ty (Sin ty x) three)))
         (Sin ty (Mul ty three x)))
(rewrite (Cos ty (Mul ty two x))
         (Sub ty (Mul ty (Cos ty x) (Cos ty x))
              (Mul ty (Sin ty x) (Sin ty x))))
(rewrite (Cos ty (Mul ty three x))
         (Sub ty (Mul ty four (Pow ty (Cos ty x) three))
              (Mul ty three (Cos ty x))))
(rewrite (Sub ty (Mul ty (Cos ty x) (Cos ty x))
              (Mul ty (Sin ty x) (Sin ty x)))
              (Cos ty (Mul ty two x)))
(rewrite  (Sub ty (Mul ty four (Pow ty (Cos ty x) three))
              (Mul ty three (Cos ty x)))
              (Cos ty (Mul ty three x)))
(rewrite (Mul ty (Sin ty x) (Sin ty x))
         (Sub ty (Num (rational "1" "2"))
              (Mul ty (Num (rational "1" "2"))
                   (Cos ty (Mul ty two x)))))
(rewrite (Mul ty (Cos ty x) (Cos ty x))
         (Add ty (Num (rational "1" "2"))
              (Mul ty (Num (rational "1" "2"))
                   (Cos ty (Mul ty two x)))))

(rewrite (Sub ty (Sin ty x) (Sin ty y)) ;; verified
         (Mul ty two (Mul ty (Sin ty (Div ty (Sub ty x y) two))
                       (Cos ty (Div ty (Add ty x y) two)))))
(rewrite (Sub ty (Cos ty x) (Cos ty y)) ;; verified
         (Mul ty (Neg ty two) (Mul ty (Sin ty (Div ty (Add ty x y) two))
                             (Sin ty (Div ty (Sub ty x y) two)))))
(rewrite (Mul ty (Cos ty x) (Cos ty y)) ;; verified
       (Div ty (Add ty (Cos ty (Add ty x y))
                 (Cos ty (Sub ty x y)))
       two))
(rewrite (Mul ty (Sin ty x) (Sin ty y)) ;; verified
       (Div ty (Sub ty (Cos ty (Sub ty x y))
                 (Cos ty (Add ty x y)))
       two))
(rewrite (Mul ty (Sin ty x) (Cos ty y))
         (Div ty (Add ty (Sin ty (Sub ty x y))
                   (Sin ty (Add ty x y)))
              two))
(rewrite (Sub ty (Atan ty x) (Atan ty y))
         (Atan2 ty (Sub ty x y) (Add ty one (Mul ty x y))))
(rewrite (Add ty (Atan ty x) (Atan ty y))
         (Atan2 ty (Add ty x y) (Sub ty one (Mul ty x y))))
(rewrite (Tan ty x) (Div ty (Sin ty x) (Cos ty x)))
(rewrite (Div ty (Sin ty x) (Cos ty x)) (Tan ty x))
(rewrite (Tan ty (Div ty (Add ty x y) two))
         (Div ty (Add ty (Sin ty x) (Sin ty y))
              (Add ty (Cos ty x) (Cos ty y))))
(rewrite (Tan ty (Div ty (Sub ty x y) two))
         (Div ty (Sub ty (Sin ty x) (Sin ty y))
              (Add ty (Cos ty x) (Cos ty y))))
(rewrite (Mul ty (Sin ty x) (Sin ty x))
         (Sub ty one (Mul ty (Cos ty x) (Cos ty x))))
(rewrite (Mul ty (Cos ty x) (Cos ty x))
         (Sub ty one (Mul ty (Sin ty x) (Sin ty x))))


;; trig inverses
(rule ((= t1 (Sin ty (Asin ty x)))
       (= l (lo t1))
       (= h (hi t1))
       (>= l r-neg-one)
       (<= h r-one))
    ((union x t1)))  
(rule ((= t1 (Cos ty (Acos ty x)))
       (= l (lo t1))
       (= h (hi t1))
       (>= l r-neg-one)
       (<= h r-one))
    ((union x t1)))  
(rewrite (Tan ty (Atan ty x)) x)
(rule ((= t1 (Atan ty (Tan ty x)))
       (= l (lo t1))
       (= h (hi t1))
       (>= l r-neg-one)
       (<= h r-one))
    ((union x t1)))



;; specialied numerical functions
(rewrite (Sub ty (Exp ty x) one)
         (Expm1 ty x))
(rewrite (Log ty (Add ty one x))
         (Log1p ty x))
(rewrite (Log1p ty (Expm1 ty x)) x)
(rule ((= t1 (Expm1 ty (Log1p ty x)))
       (= l (lo x))
       (> l r-neg-one))
       ((union x t1)))
(rewrite (Sqrt ty (Add ty (Mul ty x x) (Mul ty y y)))
         (Hypot ty x y))
(rewrite (Sqrt ty (Add ty one (Mul ty y y)))
         (Hypot ty one y))
(rewrite (Add ty (Mul ty x y) z)
         (Fma ty x y z))
(rewrite (Fma ty x y z)
         (Add ty (Mul ty x y) z))
(rewrite (Sub ty (Mul ty x y) z)
         (Fma ty x y (Neg ty z)))

(rewrite (Expm1 ty x) (Sub ty (Exp ty x) one))
(rewrite (Log1p ty x) (Log ty (Add ty one x)))
(rewrite (Hypot ty x y) (Sqrt ty (Add ty (Mul ty x x) (Mul ty y y))))



(add-ruleset rules)
(clear-rules)

;; Herbie then adds expressions here and runs them

;;(define e (Add one zero))
;;(load-ruleset analysis)
;;(run 10)
;;(clear-rules)

;;(load-ruleset rules)
;;(run 1)
;;(clear-rules)
