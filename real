infra/travis.rkt:               [output-repr-name (representation-name repr)]
infra/travis.rkt:               [var-repr-names
src/conversions.rkt:(provide generate-conversions generate-prec-rewrites *conversions* apply-repr-change)
src/conversions.rkt:(define (repr->symbol repr)
src/conversions.rkt:;; Generates conversion, repr-rewrite operators for prec1 and prec2
src/conversions.rkt:  (define prec1* (repr->symbol repr1))
src/conversions.rkt:  (define prec2* (repr->symbol repr2))
src/conversions.rkt:    (define impl (compose (representation-bf->repr repr2) (representation-repr->bf repr1)))
src/conversions.rkt:    (define impl (compose (representation-bf->repr repr1) (representation-repr->bf repr2)))
src/conversions.rkt:  (define repr-rewrite1 (sym-append '<- prec1*))
src/conversions.rkt:  (define repr-rewrite2 (sym-append '<- prec2*))
src/conversions.rkt:  (unless (impl-exists? repr-rewrite1)
src/conversions.rkt:    (register-operator-impl! 'convert repr-rewrite1 (list repr1) repr1
src/conversions.rkt:  (unless (impl-exists? repr-rewrite2)
src/conversions.rkt:    (register-operator-impl! 'convert repr-rewrite2 (list repr2) repr2
src/conversions.rkt:  (define prec1* (repr->symbol repr1)) ; fixed point workaround
src/conversions.rkt:  (define prec2* (repr->symbol repr2))
src/conversions.rkt:  (define repr-rewrite1 (sym-append '<- prec1*))
src/conversions.rkt:  (define repr-rewrite2 (sym-append '<- prec2*))
src/conversions.rkt:               (operator-exists? repr-rewrite1)
src/conversions.rkt:               (operator-exists? repr-rewrite2))
src/conversions.rkt:    (list (list rulename1 'a `(,conv1 (,repr-rewrite1 a)))))
src/conversions.rkt:    (list (list rulename2 'a `(,conv2 (,repr-rewrite2 a)))))
src/conversions.rkt:(define (apply-repr-change-expr expr ctx)
src/conversions.rkt:     [(list (? repr-conv? op) body)
src/conversions.rkt:       [(not body*) #f] ; propagate failed repr-change
src/conversions.rkt:        (define new-conv (get-repr-conv irepr repr*)) ; try to find a single conversion
src/conversions.rkt:            (let ([second-conv (get-repr-conv orepr repr*)]) ; try a two-step conversion
src/conversions.rkt:     [(list (? rewrite-repr-op? rr) (list (? repr-conv? op) body))  ; repr change on a conversion
src/conversions.rkt:              (let* ([conv (get-repr-conv repr* (context-repr ctx))]
src/conversions.rkt:     [(list (? rewrite-repr-op? op) body)
src/conversions.rkt:        (define conv (get-repr-conv irepr orepr))
src/conversions.rkt:        (define cast (get-repr-conv var-repr repr))
src/conversions.rkt:(define (apply-repr-change prog ctx)
src/conversions.rkt:   [(list 'FPCore (list vars ...) body) `(FPCore ,vars ,(apply-repr-change-expr body ctx))]
src/conversions.rkt:   [(list (or 'λ 'lambda) (list vars ...) body) `(λ ,vars ,(apply-repr-change-expr body ctx))]
src/conversions.rkt:   [_ (apply-repr-change-expr prog ctx)]))
src/core/bsearch.rkt:        (define repr (repr-of (sp-bexpr splitpoint) ctx))
src/core/bsearch.rkt:        `(if (,<=-operator ,(sp-bexpr splitpoint) ,(repr->real (sp-point splitpoint) repr))
src/core/bsearch.rkt:  (define repr (repr-of expr ctx))
src/core/bsearch.rkt:    (let ([left ((representation-repr->bf repr) p1)]
src/core/bsearch.rkt:          [right ((representation-repr->bf repr) p2)])
src/core/bsearch.rkt:  (define ctx* (struct-copy context ctx [repr (repr-of bexpr ctx)]))
src/core/egg-herbie.rkt:      [(list (? repr-conv? op) 'real arg)
src/core/egg-herbie.rkt:        [(list (? repr-conv? op) arg)
src/core/egg-herbie.rkt:      [(list (? repr-conv? op) arg)
src/core/matcher.rkt:  (define expr-repr (repr-of expr ctx))
src/core/matcher.rkt:  (define reprs (map (λ (e) (repr-of e ctx)) exprs))
src/core/reduce.rkt:    [(list (? repr-conv? op) body) ; conversion (e.g. posit16->f64)
src/core/regimes.rkt:  (define repr (repr-of expr ctx))
src/cost.rkt:       [(? repr-conv?) 2]
src/float.rkt: real->repr repr->real)
src/float.rkt:  (define ->ordinal (representation-repr->ordinal repr))
src/float.rkt:   (floor (/ (+ ((representation-repr->ordinal repr) p1)
src/float.rkt:                ((representation-repr->ordinal repr) p2))
src/float.rkt:  (define ->ordinal (representation-repr->ordinal repr))
src/float.rkt:  (define ->ordinal (representation-repr->ordinal repr))
src/float.rkt:             'ordinal (~a ((representation-repr->ordinal repr) x)))]))
src/float.rkt:  (define ->bf (representation-repr->bf repr))
src/float.rkt:(define (repr->real x repr)
src/float.rkt:    [_ (bigfloat->real ((representation-repr->bf repr) x))]))
src/ground-truth.rkt:  (define ->bf (representation-repr->bf repr))
src/mainloop.rkt:      (alt (apply-repr-change prog* ctx) 'start '()))))
src/patch.rkt:  (define repr (repr-of expr (*context*)))
src/patch.rkt:  (define-values (expansive-or-repr-change normal)
src/patch.rkt:    (partition (λ (r) (expr-contains? (rule-output r) rewrite-repr-op?))
src/patch.rkt:               expansive-or-repr-change))
src/patch.rkt:           (define prog* (apply-repr-change change-app (*context*)))
src/programs.rkt:         type-of repr-of
src/programs.rkt:(define (repr-of expr ctx)
src/programs.rkt:   [(list 'if cond ift iff) (repr-of ift ctx)]
src/programs.rkt:     ['bf (λ (x repr) (if (bigfloat? x) x ((representation-repr->bf repr) x)))]
src/programs.rkt:     ['ival (λ (x repr) (if (ival? x) x (ival ((representation-repr->bf repr) x))))]))
src/sampling.rkt:  (define ->ordinal (compose (representation-repr->ordinal repr) (representation-bf->repr repr)))
src/searchreals.rkt:(define (repr-round repr dir point)
src/searchreals.rkt:  ((representation-repr->bf repr)
src/searchreals.rkt:             (define ->ordinal (compose (representation-repr->ordinal repr)
src/searchreals.rkt:  ; Midpoint is taken in repr-space, but values are stored in bf
src/searchreals.rkt:  (define <-ordinal (compose (representation-repr->bf repr) (representation-ordinal->repr repr)))
src/searchreals.rkt:  (define ->ordinal (compose (representation-repr->ordinal repr) (representation-bf->repr repr)))
src/searchreals.rkt:  (define higher (repr-round repr 'up (bfnext lower))) ; repr-next
src/syntax/read.rkt:              preprocess output-repr-name var-repr-names conversion-syntax) #:prefab)
src/syntax/read.rkt:  (get-representation (test-output-repr-name test)))
src/syntax/read.rkt:  (define output-repr (get-representation (test-output-repr-name test)))
src/syntax/read.rkt:      (get-representation (dict-ref (test-var-repr-names test) var))))
src/syntax/read.rkt:  (for/list ([(k v) (in-dict (test-var-repr-names test))])
src/syntax/rules.rkt:(define-values (type-of-rule repr-of-rule)
src/syntax/rules.rkt:    (define ((type/repr-of-rule get-info name) input output ctx)
src/syntax/rules.rkt:                                    ; return the 'type/repr-of-rule' of the ift branch
src/syntax/rules.rkt:                                    ; return the 'type/repr-of-rule' of the ift branch
src/syntax/rules.rkt:    (values (type/repr-of-rule real-operator-info 'type-of-rule)
src/syntax/rules.rkt:            (type/repr-of-rule operator-info 'repr-of-rule))))
src/syntax/rules.rkt:            (repr-of-rule input output var-ctx))))
src/syntax/sugar.rkt:           (define conv (get-repr-conv irepr repr))
src/syntax/sugar.rkt:        [(list (? repr-conv? op) body) ; conversion (e.g. posit16->f64)
src/syntax/sugar.rkt:           (define conv (get-repr-conv vrepr repr))
src/syntax/sugar.rkt:    [(list (? repr-conv? op) body) ; conversion (e.g. posit16->f64)
src/syntax/syntax-check.rkt:         [(list repr-name-1 repr-name2)
src/syntax/syntax.rkt:         repr-conv? rewrite-repr-op?
src/syntax/syntax.rkt:         get-repr-conv get-rewrite-operator)
src/syntax/syntax.rkt:(define (repr-conv? expr)
src/syntax/syntax.rkt:(define (rewrite-repr-op? expr)
src/syntax/syntax.rkt:(define (get-repr-conv irepr orepr)
src/syntax/type-check.rkt:(define (repr-has-type? repr type)
src/syntax/type-check.rkt:         (when (or (equal? rtype type) (repr-has-type? rtype 'bool))
src/syntax/type-check.rkt:     (unless (or (equal? type vtype) (repr-has-type? vtype 'bool))
src/syntax/type-check.rkt:     (unless (repr-has-type? branch-type 'bool)
src/syntax/type-check.rkt:       (when (repr-has-type? actual-type 'bool)
src/syntax/type-check.rkt:       (when (repr-has-type? actual-type 'bool)
src/syntax/type-check.rkt:       (unless (repr-has-type? actual-type 'bool)
src/syntax/types.rkt:   bf->repr repr->bf ordinal->repr repr->ordinal
src/syntax/types.rkt:(define repr-generators '())
src/syntax/types.rkt:  (unless (set-member? repr-generators proc)
src/syntax/types.rkt:    (set! repr-generators (cons proc repr-generators))))
src/syntax/types.rkt:(define (generate-repr repr-name)
src/syntax/types.rkt:  (or (hash-has-key? representations repr-name)
src/syntax/types.rkt:      (for/or ([proc repr-generators])
src/syntax/types.rkt:                   (not (hash-has-key? representations repr-name)))
src/syntax/types.rkt:            repr-name))
src/syntax/types.rkt:          (proc repr-name)))))
src/web/demo.rkt:                  (real->ordinal (repr->real val repr) repr))
src/web/pages.rkt:        (repr->real x repr))))
src/web/pages.rkt:            (real->ordinal (repr->real val repr) repr))
src/web/plot.rkt:  (repr->real ((representation-ordinal->repr repr) x) repr))
src/web/plot.rkt:  ((representation-repr->ordinal repr) (real->repr x repr))) 
www/doc/1.5/plugins.html:        <tr><td></td><td><i>repr->bigfloat</i></td></tr>
www/doc/1.5/plugins.html:        <tr><td></td><td><i>repr->ordinal</i></td></tr>
www/doc/1.5/plugins.html:        <tr><td></td><td><i>repr->bigfloat</i></td></tr>
www/doc/1.5/plugins.html:        <tr><td></td><td><i>repr->ordinal</i></td></tr>
www/doc/1.6/plugins.html:        <tr><td></td><td><i>repr->bigfloat</i></td></tr>
www/doc/1.6/plugins.html:        <tr><td></td><td><i>repr->ordinal</i></td></tr>
www/doc/1.6/plugins.html:        <tr><td>(<b>define-operator-impl</b> (<i>op</i> <i>name</i> <i>irepr-names ...</i>)</td><td><i>orepr-name</i></td></tr>
www/doc/1.6/plugins.html:    <dd>Implements <code><i>op</i></code> with input representation(s) <code><i>irepr-names</i></code>
www/doc/1.6/plugins.html:      and output representation <code><i>orepr-name</i></code>.
www/doc/1.6/plugins.html:        <tr><td></td><td><i>repr->bigfloat</i></td></tr>
www/doc/1.6/plugins.html:        <tr><td></td><td><i>repr->ordinal</i></td></tr>
www/doc/1.6/plugins.html:        <i>var-repr-names</i> <i>rules</i>)</code>
www/doc/1.6/plugins.html:        <code><i>var-repr-names</i></code> is an association
www/doc/1.7/plugins.html:        <tr><td></td><td><i>repr->bigfloat</i></td></tr>
www/doc/1.7/plugins.html:        <tr><td></td><td><i>repr->ordinal</i></td></tr>
www/doc/1.7/plugins.html:        <tr><td>(<b>define-operator-impl</b> (<i>op</i> <i>name</i> <i>irepr-names ...</i>)</td><td><i>orepr-name</i></td></tr>
www/doc/1.7/plugins.html:    <dd>Implements <code><i>op</i></code> with input representation(s) <code><i>irepr-names</i></code>
www/doc/1.7/plugins.html:      and output representation <code><i>orepr-name</i></code>.
www/doc/1.7/plugins.html:        <tr><td></td><td><i>repr->bigfloat</i></td></tr>
www/doc/1.7/plugins.html:        <tr><td></td><td><i>repr->ordinal</i></td></tr>
www/doc/1.7/plugins.html:        <i>var-repr-names</i> <i>rules</i>)</code>
www/doc/1.7/plugins.html:        <code><i>var-repr-names</i></code> is an association
